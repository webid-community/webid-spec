<?xml version='1.0' encoding='UTF-8'?>
<!DOCTYPE html>
<html>
  <head>
    <title>WebID 1.0</title>
    <meta http-equiv='Content-Type' content='text/html;charset=utf-8'/>
    <!-- 
      === NOTA BENE ===
      For the three scripts below, if your spec resides on dev.w3 you can check them
      out in the same tree and use relative links so that they'll work offline,
     -->
<style type='text/css'>
code           { font-family: monospace; }

span.hilite { color: red; /* font-weight: bold */ }

li p           { margin-top: 0.3em;
                 margin-bottom: 0.3em; }

div.explanation { background-color: #ADD8E6;
                   width: 80%;
                   margin: 12px; padding: 8px; }
div.explanation li { margin-top: 8px; }
div.explanation dd { margin: 4px; }

.adef { 
	font-family: monospace; 
	font-weight: bold; 
    color: #ff4500 !important;
}

.aref { 
	font-family: monospace; 
	font-weight: bold; 
    color: #ff4500 !important;
}

span.entity { color: red; }

span.element { color: green; }
</style>

    <script src='http://dev.w3.org/2009/dap/ReSpec.js/js/respec.js' class='remove'></script> 
<!--    <script src='/ReSpec.js/js/respec.js' class='remove'></script> -->
    <script class='remove'>
      var preProc = {
          apply:  function(c) {
                    // process the document before anything else is done
                    var refs = document.querySelectorAll('adef') ;
                    for (var i = 0; i < refs.length; i++) {
                        var item = refs[i];
                        var p = item.parentNode ;
                        var con = item.innerHTML ;
                        var sp = document.createElement( 'dfn' ) ;
                        var tit = item.getAttribute('title') ;
                        if (!tit) {
                            tit = con;
                        }
                        sp.className = 'adef' ;
                        sp.title=tit ;
                        sp.innerHTML = con ;
                        p.replaceChild(sp, item) ;
                    }
                    refs = document.querySelectorAll('aref') ;
                    for (var i = 0; i < refs.length; i++) {
                        var item = refs[i];
                        var p = item.parentNode ;
                        var con = item.innerHTML ;
                        var sp = document.createElement( 'a' ) ;
                        sp.className = 'aref' ;
                        sp.setAttribute('title', con);
                        sp.innerHTML = '@'+con ;
                        p.replaceChild(sp, item) ;
                    }
                    // local datatype references
                    refs = document.querySelectorAll('ldtref') ;
                    for (var i = 0; i < refs.length; i++) {
                        var item = refs[i];
                        if (!item) continue ;
                        var p = item.parentNode ;
                        var con = item.innerHTML ;
                        var ref = item.getAttribute('title') ;
                        if (!ref) {
                            ref = item.textContent ;
                        }
                        if (ref) {
                            ref = ref.replace(/\n/g, '_') ;
                            ref = ref.replace(/\s+/g, '_') ;
                        }
                        var sp = document.createElement( 'a' ) ;
                        sp.className = 'datatype';
                        sp.title = ref ;
                        sp.innerHTML = con ;
                        p.replaceChild(sp, item) ;
                    }
                    // external datatype references
                    refs = document.querySelectorAll('dtref') ;
                    for (var i = 0; i < refs.length; i++) {
                        var item = refs[i];
                        if (!item) continue ;
                        var p = item.parentNode ;
                        var con = item.innerHTML ;
                        var ref = item.getAttribute('title') ;
                        if (!ref) {
                            ref = item.textContent ;
                        }
                        if (ref) {
                            ref = ref.replace(/\n/g, '_') ;
                            ref = ref.replace(/\s+/g, '_') ;
                        }
                        var sp = document.createElement( 'a' ) ;
                        sp.className = 'externalDFN';
                        sp.title = ref ;
                        sp.innerHTML = con ;
                        p.replaceChild(sp, item) ;
                    }
                    // now do terms
                    refs = document.querySelectorAll('tdef') ;
                    for (var i = 0; i < refs.length; i++) {
                        var item = refs[i];
                        if (!item) continue ;
                        var p = item.parentNode ;
                        var con = item.innerHTML ;
                        var ref = item.getAttribute('title') ;
                        if (!ref) {
                            ref = item.textContent ;
                        }
                        if (ref) {
                            ref = ref.replace(/\n/g, '_') ;
                            ref = ref.replace(/\s+/g, '_') ;
                        }
                        var sp = document.createElement( 'dfn' ) ;
                        sp.title = ref ;
                        sp.innerHTML = con ;
                        p.replaceChild(sp, item) ;
                    }
                    // now term references
                    refs = document.querySelectorAll('tref') ;
                    for (var i = 0; i < refs.length; i++) {
                        var item = refs[i];
                        if (!item) continue ;
                        var p = item.parentNode ;
                        var con = item.innerHTML ;
                        var ref = item.getAttribute('title') ;
                        if (!ref) {
                            ref = item.textContent ;
                        }
                        if (ref) {
                            ref = ref.replace(/\n/g, '_') ;
                            ref = ref.replace(/\s+/g, '_') ;
                        }

                        var sp = document.createElement( 'a' ) ;
                        var id = item.textContent ;
                        sp.className = 'tref' ;
                        sp.title = ref ;
                        sp.innerHTML = con ;
                        p.replaceChild(sp, item) ;
                    }
                }
        } ;


      var respecConfig = {
          // specification status (e.g. WD, LCWD, NOTE, etc.). If in doubt use ED.
          // embed RDFa data in the output
          doRDFa: true,
          specStatus:           "unofficial",
          //publishDate:          "2010-07-05",
          diffTool:             "http://www3.aptest.com/standards/htmldiff/htmldiff.pl",
          
          // the specifications short name, as in http://www.w3.org/TR/short-name/
          shortName:            "webid",
          subtitle: "Web Identification and Discovery",

          // if you wish the publication date to be other than today, set this
          // publishDate:  "2009-08-06",
          copyrightStart:  "2010",

          // if there is a previously published draft, uncomment this and set its YYYY-MM-DD date
          // and its maturity status
          previousPublishDate:  "2010-07-11",
          previousMaturity:  "ED",
          previousURI:       "http://payswarm.com/webid/drafts/ED-webid-20100711/",


          // if there a publicly available Editors Draft, this is the link
          edDraftURI:           "http://payswarm.com/webid/",

          // if this is a LCWD, uncomment and set the end of its review period
          // lcEnd: "2009-08-05",

          // if you want to have extra CSS, append them to this list
          // it is recommended that the respec.css stylesheet be kept
          extraCSS:             ['http://dev.w3.org/2009/dap/ReSpec.js/css/respec.css'],

          // editors, add as many as you like
          // only "name" is required
          editors:  [
              { name: "Manu Sporny", mailto:"msporny@digitalbazaar.com",
                  company: "Digital Bazaar, Inc.", companyURL: "http://blog.digitalbazaar.com/" }
              ],

          // authors, add as many as you like. 
          // This is optional, uncomment if you have authors as well as editors.
          // only "name" is required. Same format as editors.

          authors:  [
              { name: "Toby Inkster", url: "http://tobyinkster.co.uk/" },
              { name: "Henry Story", url: "http://bblfish.net/" },
              { name: "Bruno Harbulot", url: "http://blog.distributedmatter.net/" },
              { name: "Reto Bachmann-Gmür", url: "http://trialox.org/" }
          ],

//          errata: 'http://www.w3.org/MarkUp/2008/REC-rdfa-syntax-20081014-errata',
          
          // name of the WG
          wg:           "Social Web XG",
          
          // URI of the public WG page
          wgURI:        "http://esw.w3.org/Foaf%2Bssl",
          
          // name (with the @w3c.org) of the public mailing to which comments are due
          wgPublicList: "socialweb-xg",
          
          // alternate formats for this document
          alternateFormats: [
              { uri: 'diff-20100711.html', 
                  label: "Diff from previous Editors Draft" }],

          // URI of the patent status for this WG, for Rec-track documents
          // !!!! IMPORTANT !!!!
          // This is important for Rec-track documents, do not copy a patent URI from a random
          // document unless you know what you're doing. If in doubt ask your friendly neighbourhood
          // Team Contact.
          wgPatentURI:  "http://www.w3.org/2004/01/pp-impl/44350/status",
          maxTocLevel: 4,
          preProcess: [ preProc ] 
      };


      function updateExample(doc, content) {
        // perform transformations to make it render and prettier
        content = content.replace(/<!--/, '');
        content = content.replace(/-->/, '');
        content = doc._esc(content);
        content = content.replace(/\*\*\*\*([^*]*)\*\*\*\*/g, '<span class="hilite">$1</span>') ;
        return content ;
      }

      function updateDTD(doc, content) {
        // perform transformations to 
        // make it render and prettier
        content = '<pre class="dtd">' + doc._esc(content) + '</pre>';
        content = content.replace(/!ENTITY % ([^ \t\r\n]*)/g, '!ENTITY <span class="entity">% $1</span>');
        content = content.replace(/!ELEMENT ([^ \t$]*)/mg, '!ELEMENT <span class="element">$1</span>');
        return content;
      }

      function updateSchema(doc, content) {
        // perform transformations to 
        // make it render and prettier
        content = '<pre class="dtd">' + doc._esc(content) + '</pre>';
        content = content.replace(/&lt;xs:element\s+name=&quot;([^&]*)&quot;/g, '&lt;xs:element name="<span class="element" id="schema_element_$1">$1</span>"') ;
        return content;
      }

      function updateTTL(doc, content) {
        // perform transformations to 
        // make it render and prettier
        content = '<pre class="sh_sourceCode">' + doc._esc(content) + '</pre>';
        content = content.replace(/@prefix/g, '<span class="sh_keyword">@prefix</span>');
        return content;
      }
    </script>
  </head>
  <body>
    <section id='abstract'>

<p>Social networking, identity and privacy have been at the center of how we 
interact with the Web in the last decade. The explosion of social networking 
sites has brought the world closer together as well as created new points of
pain regarding ease of use and the Web. Remembering login details, passwords,
and sharing private information across the many websites and social groups
that we are a part of has become more difficult and complicated than necessary. 
The Social Web is designed to ensure that control of identity and privacy 
settings is always simple and under one's control. WebID is a key enabler of the 
Social Web. This specification outlines a simple universal identification 
mechanism that is distributed, openly extensible, improves privacy, security 
and control over how one can identify themselves and control access to their 
information on the Web.
</p>
  
<section>
<h2>How to Read this Document</h2>
  
<p>There are a number of concepts that are covered in this document that the
reader may want to be aware of before continuing. General knowledge of
<a href="http://en.wikipedia.org/wiki/Public_key_cryptography">public key cryptography</a> 
and RDF [[!RDF-PRIMER]] and RDFa [[!RDFA-CORE]] is necessary to understand how 
to implement this specification. WebID uses a number of specific technologies 
like HTTP over TLS [[!HTTP-TLS]], X.509 certificates [[!X509V3]], 
RDF/XML [[!RDF-SYNTAX-GRAMMAR]] and XHTML+RDFa [[!XHTML-RDFA]].</p>

<p>A general <a href="#introduction">Introduction</a> is provided for all that
would like to understand why this specification is necessary to simplify usage
of the Web.</p>

<p>The terms used throughout this specification are listed in the section
titled <a href="#terminology">Terminology</a>.</p>

<p>Developers that are interested in implementing this specification will be
most interested in the sections titled 
<a href="#authentication-sequence">Authentication Sequence</a> and 
<a href="#authentication-sequence-details">Authentication Sequence Details</a></p>.
  
</section>
</section>

<section id='sotd'>
<!-- <p>This document has been reviewed by W3C Members, by software
developers, and by other W3C groups and interested parties, and is
endorsed by the Director as a W3C Recommendation. It is a stable
document and may be used as reference material or cited from another
document. W3C's role in making the Recommendation is to draw attention
to the specification and to promote its widespread deployment. This
enhances the functionality and interoperability of the Web.</p> -->

The source code for this document is available via Github at the following
URI: <a href="http://github.com/msporny/webid-spec">http://github.com/msporny/webid-spec</a>

</section>

<section class='informative'>
<h1>Introduction</h1>

<p>
The WebID specification is designed to help alleviate the difficultly that
remembering different logins, passwords and settings for websites has created. 
It is also designed to provide a universal and extensible mechanism to express 
public and private information about yourself. This section outlines the 
motivation behind the specification and the relationship to other similar 
specifications that are in active use today.
</p>

<section class='informative'>
<h1>Motivation</h1>

<p>
It is a fundamental design criteria of the Web to enable individuals and
organizations to control how they interact with the rest of society. This
includes how one expresses their identity, public information and personal 
details to social networks, Web sites and services.
</p>

<p>
Semantic Web vocabularies such as Friend-of-a-Friend (FOAF) permit distributed 
hyperlinked social networks to exist. This vocabulary, along with other 
vocabularies, allow one to add information and services protection to 
distributed social networks.
</p>

<p>
One major criticism of open networks is that they seem to have no way of
protecting the personal information distributed on the web or limiting
access to resources. Few people are willing to make all their personal
information public, many would like large pieces to be protected, making
it available only to a selected group of agents. Giving access to
information is very similar to giving access to services. There are many
occasions when people would like services to only be accessible to
members of a group, such as allowing only friends, family members,
colleagues to post an article, photo or comment on a blog. How does one do
this in a flexible way, without requiring a central point of
access control?
</p>

<p>
Using a process made popular by OpenID, we show how one can tie a User
Agent to a URI by proving that one has write access to the URI.
WebID is an authentication protocol which uses X.509 
certificates to associate a User Agent (Browser) to a Person identified via a URI.
WebID is compatible with OpenID and provides a few additional features such as
trust management via digital signatures, and free-form 
extensibility via RDF. By using the existing SSL certificate exchange
mechanism, WebID integrates smoothly with existing Web browsers, including
browsers on mobile devices. WebID also permits automated session login
in addition to interactive session login. Additionally, all data is encrypted
and guaranteed to only be received by the person or organization that was 
intended to receive it.
</p>

</section>

</section>

<section class='normative'>
<h1>The WebID Protocol</h1>

<section class='normative'>
<h1>Terminology</h1>

<dl>

<dt><tdef>Verification Agent</tdef></dt>
<dd>Performs authentication on provided WebID credentials and determines if
an <tref>Identification Agent</tref> can have access to a particular 
resource. A <tref>Verification Agent</tref> is typically a Web server, but 
may also be a peer on a peer-to-peer network.</dd>

<dt><tdef>Identification Agent</tdef></dt>
<dd>Provides identification credentials to a <tref>Verification Agent</tref>. The
<tref>Identification Agent</tref> is typically also a User Agent.</dd>

<dt><tdef>Identification Certificate</tdef></dt>
<dd>An X.509 [[!X509V3]] Certificate that MUST contain a 
<code>Subject Alternative Name</code> extension with a URI entry. The URI
identifies the <tref>Identification Agent</tref>. The URI SHOULD be
dereference-able and result in a document containing RDF data. For example, 
the certificate would contain <code>http://example.org/webid#public</code>,
known as a <tref>WebID URI</tref>, as the <code>Subject Alternative Name</code>:
<pre>
X509v3 extensions:
   ...
   X509v3 Subject Alternative Name:
      URI:http://example.org/webid#public
</pre>
</dd>

<dt><tdef>WebID URI</tdef></dt>
<dd>A URI specified via the <code>Subject Alternative Name</code> extension
of the <tref>Identification Certificate</tref> that identifies an 
<tref>Identification Agent</tref>.</dd>

<dt><tdef>public key</tdef></dt>
<dd>A widely distributed cryptographic key that can be used to verify 
digital signatures and encrypt data between a sender and a receiver. A public
key is always included in an <tref>Identification Certificate</tref>.</dd>

<dt><tdef>WebID Profile</tdef></dt>
<dd>
A structured document that contains identification credentials for the 
<tref>Identification Agent</tref> expressed using the Resource Description
Framework [[RDF-CONCEPTS]]. Either the XHTML+RDFa 1.1 [[!XHTML-RDFA]] 
serialization format or the RDF/XML [[!RDF-SYNTAX-GRAMMAR]] serialization
format MUST be supported by the mechanism, e.g. a Web Service, providing the
WebID Profile document. Alternate RDF serialization
formats, such as N3 [[!N3]] or Turtle [[!TURTLE]], MAY be supported by the 
mechanism providing the WebID Profile document.
</dd>

</dl>

<p class="issue">Whether or not RDF/XML, XHTML+RDFa 1.1, both or neither
serialization of RDF should be required serialization formats in the 
specification is currently under heavy debate.</p>

</section>

<section class='normative'>
<h3><span class="secno">2.2 </span>Authentication Sequence</h3>

<p>The following steps are executed by Verification Agents and Identification
Agents to determine the global identity of the requesting agent. Once this is known, the identity can be used to determine if access should be granted to the requested resource.
</p>

<ol>
<li>The <a class="tref internalDFN" title="Identification_Agent" href="#dfn-identification_agent">Identification Agent</a> attempts to access a resource
using HTTP over TLS [<a class="bibref" rel="biblioentry" href="#bib-HTTP-TLS">HTTP-TLS</a>] via the <a class="tref internalDFN" title="Verification_Agent" href="#dfn-verification_agent">Verification Agent</a>.</li>

<li>The <a class="tref internalDFN" title="Verification_Agent" href="#dfn-verification_agent">Verification Agent</a> <em class="rfc2119" title="must">must</em> request the 
<a class="tref internalDFN" title="Identification_Certificate" href="#dfn-identification_certificate">Identification Certificate</a> of the <a class="tref internalDFN" title="Identification_Agent" href="#dfn-identification_agent">Identification Agent</a>
as a part of the TLS client-cerificate retrieval protocol.</li>

<li>The <a class="tref internalDFN" title="Verification_Agent" href="#dfn-verification_agent">Verification Agent</a> <em class="rfc2119" title="must">must</em> extract the <a class="tref internalDFN" title="public_key" href="#dfn-public_key">public key</a> and the
<a class="tref internalDFN" title="WebID_URL" href="#dfn-webid_url">WebID URL</a> contained in the <code>Subject Alternative Name</code> 
extension of the <a class="tref internalDFN" title="Identification_Certificate" href="#dfn-identification_certificate">Identification Certificate</a>. <p class="issue">There may be more than one URI in the SAN</p> </li>
<li>
The <a class="tref internalDFN" title="Verification_Agent" href="#dfn-verification_agent">Verification Agent</a> verifies that the 
<a class="tref internalDFN" title="Identification_Agent" href="#dfn-identification_agent">Identification Agent</a> owns the private key corresponding to the public key  sent in the <a class="tref internalDFN" title="Identification_Certificate" href="#dfn-identification_certificate">Identification Certificate</a>. This <em class="rfc2119" title="should">should</em> be fulfilled by performing TLS mutual-authentication
between the <a class="tref internalDFN" title="Verification_Agent" href="#dfn-verification_agent">Verification Agent</a> and the 
<a class="tref internalDFN" title="Identification_Agent" href="#dfn-identification_agent">Identification Agent</a>. 
If the <a class="tref internalDFN" title="Verification_Agent" href="#dfn-verification_agent">Verification Agent</a> does not have access to the TLS layer, 
a digital signature challenge <em class="rfc2119" title="may">may</em> be provided by the 
<a class="tref internalDFN" title="Verification_Agent" href="#dfn-verification_agent">Verification Agent</a>. These processes are detailed in the section
on  
<a href="#secure-communication">Secure Communication</a>.<p class="issue">We don't have any implementations for this second way of doing things, so this is still hypothetical. Implementations using TLS mutual-authentication are many</p> </li>
<li>The meaning of the 
<a class="tref internalDFN" title="WebID_URL" href="#dfn-webid_url">WebID URL</a> is a graph of relations that is fetched by the <a class="tref internalDFN" title="Verification_Agent" href="#dfn-verification_agent">Verification Agent</a> 
by either by dereferencing the <a class="tref internalDFN" title="WebID_URL" href="#dfn-webid_url">WebID URL</a> and 
extracting RDF data from the resulting document, or by utilizing a cached 
version of the RDF data contained in the document or other data source that is 
up-to-date and trusted by the <a class="tref internalDFN" title="Verification_Agent" href="#dfn-verification_agent">Verification Agent</a>. The processing
 mechanism is further detailed in the sections titled 
<a href="#processing-the-webid-profile">Processing the WebID Profile</a>
</li>

<li>If the <a class="tref internalDFN" title="public_key" href="#dfn-public_key">public key</a> in the 
<a class="tref internalDFN" title="Identification_Certificate" href="#dfn-identification_certificate">Identification Certificate</a> matches one in the set given by the profile document graph given above then the 
<a class="tref internalDFN" title="Verification_Agent" href="#dfn-verification_agent">Verification Agent</a> knows that the <a class="tref internalDFN" title="Identification_Agent" href="#dfn-identification_agent">Identification Agent</a> is indeed identified by the <a class="tref internalDFN" title="WebID_URL" href="#dfn-webid_url">WebID URL</a>. The verification is done by querying the 
Personal Profile graph as specified in <a href="#extracting-webid-url-details">querying the RDF graph</a></li>

</ol>

<p>
The <a class="tref internalDFN" title="Identification_Agent" href="#dfn-identification_agent">Identification Agent</a> <em class="rfc2119" title="may">may</em> re-establish a different identity at 
any time by executing all of the steps in the Authentication Sequence again. 
Additional algorithms, detailed in the next section, <em class="rfc2119" title="may">may</em> be performed to 
determine if the <a class="tref internalDFN" title="Verification_Agent" href="#dfn-verification_agent">Verification Agent</a> can access a particular 
resource after the last step of the Authentication Sequence has been
completed.
</p>

</div>

<section class='normative'>
<h1>Authentication Sequence Details</h1>

<p>This section covers details about each step in the authentication process.
</p>

<section class='normative'>
<h2>Initiating a TLS Connection</h2>

<p class="issue">This section will detail how the TLS connection process is
started and used by WebID to create a secure channel between the 
Identification Agent and the Verification Agent.</p>
</section>

<section class='normative'>
<h2>Exchanging the Identification Certificate</h2>

<p class="issue">This section will detail how the certificate is selected and
sent to the Verification Agent.</p>
</section>

<section class='normative'>
<h2>Processing the WebID Profile</h2>

<p>A <tref>Verification Agent</tref> MUST be able to process documents in RDF/XML 
[[!RDF-SYNTAX-GRAMMAR]] and XHTML+RDFa [[!XHTML-RDFA]]. A server responding to 
a <tref>WebID Profile</tref> request SHOULD be able to deliver at least RDF/XML
or RDFa. The Verification Agent MUST set the Accept-Header to request
<code>application/rdf+xml</code> with a higher priority than <code>text/html</code>
and <code>application/xhtml+xml</code>. If the server answers such a request
with an HTML representation of the resource, this SHOULD describe the WebId Profile
with RDFa.
</p> 

<p class="issue">This section will explain how a Verification Agent extracts 
semantic data describing the identification credentials from a WebID Profile.</p>
</section>

<section class='normative'>
<h2>Extracting WebID URI Details</h2>

<p>
The <tref>Verification Agent</tref> may use a number of different methods to
extract the <tref>public key</tref> information from the <tref>WebID Profile</tref>.
</p>
The following SPARQL query outlines one way in which the <tref>public key</tref>
could be extracted from the <tref>WebID Profile</tref>:
<pre class='example'>
PREFIX cert: &lt;http://www.w3.org/ns/auth/cert#&gt;
PREFIX rsa: &lt;http://www.w3.org/ns/auth/rsa#&gt;
SELECT ?modulus ?exp
WHERE {
   ?key cert:identity &lt;http://example.org/webid#public&gt;;
      a rsa:RSAPublicKey;
      rsa:modulus [ cert:hex ?modulus; ];
      rsa:public_exponent [ cert:decimal ?exp ] .
}
</pre>
<p class="issue">The above query is using the original non literal method of writing a query, and does not support the literal notation. Should we in this document take that to now be deprecated?</p>
<p class="issue">The above query will work properly if the graph does inferencing on the rsa ontology. If it does not then it would be wise to remove the "a rsa:RSAPublicKey relation from the pattern.</p>
<p>Currently as a trnsition phase allowing for literals and non literal notationthe following query is adopted:</p>
<pre class='example'>
PREFIX cert: &lt;http://www.w3.org/ns/auth/cert#&gt;
PREFIX rsa: &lt;http://www.w3.org/ns/auth/rsa#&gt;
SELECT ?m ?e ?mod ?exp 
WHERE { 
   [] cert:identity ?webid ;
        rsa:modulus ?m ;
        rsa:public_exponent ?e .
   OPTIONAL { ?m cert:hex ?mod . }
   OPTIONAL { ?e cert:decimal ?exp . }
</pre>
<p>In the above query the verifier has to iterate through the answer set,
converting bindings for ?m and ?e if they are literals to integers, else to check for ?mod and ?exp and convert those to literals. In order to allow for the possibility of there being multiple ways of writing the literals, this process should be able to convert the various integer xsd formats xsd:int, xsd:nonNegativeInteger, xsd:int, ...  [TODO: check that carefully]
</p>
<p>If we move to dropping the deprecated relations - and thereby make writing the rdf easier, the query can be the much simpler</p>
<pre class='example'>
PREFIX cert: &lt;http://www.w3.org/ns/auth/cert#&gt;
PREFIX rsa: &lt;http://www.w3.org/ns/auth/rsa#&gt;
SELECT ?m ?e ?mod ?exp 
WHERE { 
   [] cert:identity ?webid ;
        rsa:modulus ?m ;
        rsa:public_exponent ?e .
}
</pre>
<p>Here the verification agent must check that one of the answers for ?m and ?e matches the public key in the certificate</p>
<p>If the triple store supports literal inferencing then the query for
a given modulus "9D79BFE2498..." and exponent "65537" 
be as simple simple as:
</p>
<pre class='example'>
PREFIX cert: &lt;http://www.w3.org/ns/auth/cert#&gt;
PREFIX rsa: &lt;http://www.w3.org/ns/auth/rsa#&gt;
ASK {
   [] cert:identity &lt;http://example.org/webid#public&gt;;
      rsa:modulus  "9D79BFE2498..."^^cert:hex;
      rsa:public_exponent "65537"^^cert:int .
}
</pre>
<p>If the above query returns True, then authentication has succeeded, otherwise not. </p>
<p>Note that this will requre the type inferencing engine to be able to
convert literals written in the profile document as "9D ☮ 79 ☮ BF ☮ E2 ☮ F4 ☮ 98 ☮" into the integer.
</p>

<p class="issue">This section still needs more information.</p>

</section>

<section class='normative'>
<h2>Authorization</h2>

<p class="issue">This section will explain how a Verification Agent may
use the information discovered via a WebID URI to determine if one should
be able to access a particular resource. It will explain how a Verification
Agent can use links to other RDFa documents to build knowledge about the
given WebID.</p>

</section>

<section class='normative'>
<h2>Secure Communication</h2>

<p class="issue">This section will explain how an Identification Agent and
a Verification Agent may communicate securely using a set of verified
identification credentials.</p>

<p>
If the <tref>Verification Agent</tref> has verified that the
<tref>WebID Profile</tref> is owned by the <tref>Identification Agent</tref>, 
the <tref>Verification Agent</tref> SHOULD use the verified 
<tref>public key</tref> contained in the <tref>Identification Certificate</tref> 
for all TLS-based communication with the <tref>Identification Agent</tref>.
This ensures that both the <tref>Verification Agent</tref> and the 
<tref>Identification Agent</tref>
are communicating in a secure manner, ensuring cryptographically protected
privacy for both sides.
</p>

</section>

</section>

<section class='normative'>
<h2>The WebID Profile</h2>

<p>The <tref>WebID Profile</tref> is a structured document that contains 
identification credentials for the <tref>Identification Agent</tref> expressed 
using the Resource Description Framework [[RDF-CONCEPTS]]. The following 
sections describe how to express certain common properties that could be used
by <tref>Verification Agent</tref>s and other entities that consume a 
<tref>WebID Profile</tref>.</p>

<p>The following vocabularies are used in their shortened form in the 
subsequent sections:</p>

<dl>
  <dt>foaf</dt>
  <dd>http://xmlns.com/foaf/0.1/</dd>
  <dt>cert</dt>
  <dd>http://www.w3.org/ns/auth/cert#</dd>
  <dt>rsa</dt>
  <dd>http://www.w3.org/ns/auth/rsa#</dd>
</dl>

<section class='normative'>
<h2>Personal Information</h2>

<p>Personal details are the most common requirement when registering an 
account with a website. Some of these pieces of information include an e-mail 
address, a name and perhaps an avatar image. This section includes
properties that SHOULD be used when conveying key pieces of personal 
information but are NOT REQUIRED to be present in a <tref>WebID Profile</tref>:</p>

<dl>
  <dt>foaf:mbox</dt>
  <dd>The e-mail address that is associated with the WebID URI.</dd>
  <dt>foaf:name</dt>
  <dd>The name that is most commonly used to refer to the individual 
    or agent.</dd>
  <dt>foaf:depiction</dt>
  <dd>An image representation of the individual or agent.</dd>
</dl>
</section>

<section class='normative'>
<h2>Cryptographic Details</h2>

<p>Cryptographic details are important when <tref>Verification Agent</tref>s
and <tref>Identification Agent</tref>s interact. The following properties 
SHOULD be used when conveying cryptographic information in <tref>WebID Profile</tref>
documents:</p>

<dl>
  <dt>rsa:RSAPublicKey</dt>
  <dd>Expresses an RSA public key. The RSAPublicKey MUST specify the
  rsa:modulus and rsa:public_exponent properties.</dd>
  <dt>cert:identity</dt>
  <dd>Used to associate an RSAPublicKey with a WebID URI. A WebID Profile
  MUST contain at least one RSAPublicKey that is associated with the
  corresponding WebID URI.</dd>
</dl>
</section>

</section>

</section>

<section class='appendix informative' id="history">
<h1>Change History</h1>
<p><a href="http://github.com/msporny/webid-spec/commit/b19d2812901b4511fdf9876c1be53bb36ee3201e">2010-07-25</a> Added WebID Profile section.</p>
<p><a href="http://github.com/msporny/webid-spec/commit/211d197510ca119c21ae48f3e5aa3f931ea88672">2010-07-18</a> Updates from WebID community related to RDF/XML support, authentication sequence corrections, abstract and introduction updates.</p>
<p><a href="http://github.com/msporny/webid-spec/commit/a54dee9c242b08edaac617d678215b389dd3556d">2010-07-11</a> Initial version.</p>
</section>

<section class='informative' id="acknowledgements">
<h1>Acknowledgments</h1>

<p>The following people have been instrumental in providing thoughts, feedback,
reviews, criticism and input in the creation of this specification:</p>

<ul>
<li>Melvin Carvalho</li>
<li>Bruno Harbulot</li>
<li>Toby Inkster</li>
<li>Ian Jacobi</li>
<li>Jeff Sayre</li>
<li>Henry Story</li>
<li>Kingsley Idehen, OpenLink Software</li>
<li>Seth Russell</li>
<li>Sarven Capadisli</li>
<li>Nathan Rixham</li>
</ul>

</section>
  </body>
</html>

